# Usage

## Download ids for ZTF fields/CCDs/quadrants

- Create CSV file for single CCD/quad pair in a field:

```sh
./get_quad_ids.py --catalog ZTF_source_features_DR5 --field 301 --ccd 2 --quad 3 --minobs 20 --skip 0 --limit 10000
```

- Create multiple HDF5 files for some CCD/quad pairs in a field:

```sh
./get_quad_ids.py --catalog ZTF_source_features_DR5 --field 301 --multi-quads --ccd-range 1 8 --quad-range 2 4 --minobs 20 --limit 10000
```

- Create multiple HDF5 files for all CCD/quad pairs in a field:

```sh
./get_quad_ids.py --catalog ZTF_source_features_DR5 --field 301 --multi-quads --minobs 20 --limit 10000
```

- Create single HDF5 file for all sources in a field:

```sh
./get_quad_ids.py --catalog ZTF_source_features_DR5 --field 301 --whole-field
```

## Training deep learning models

For details on the SCoPe taxonomy and architecture,
please refer to [arxiv:2102.11304](https://arxiv.org/pdf/2102.11304.pdf).

- The training pipeline can be invoked with the `scope.py` utility. For example:

```sh
./scope.py train --tag=vnv --path_dataset=data/training/dataset.d15.csv --batch_size=64 --epochs=100 --verbose=1 --pre_trained_model=models/experiment/vnv/vnv.20221117_001502.h5
```

Refer to `./scope.py train --help` for details.

- All the necessary metadata/configuration could be defined in `config.yaml` under `training`,
but could also be overridden with optional `scope.py train` arguments, e.g.
`./scope.py train ... --batch_size=32 --threshold=0.6 ...`.

- The pipeline uses the `ScopeNet` models defined in `scope.nn` as subclassed `tf.keras.models.Model`'s.
- The `Dataset` class defined in `scope.utils` hides the complexity of our dataset handling "under the rug".
- Datasets and pre-trained models could be fetched from the GCS with the `scope.py` tool:

```sh
./scope.py fetch-datasets
./scope.py fetch-models
```

  This requires permissions to access the `gs://ztf-scope` bucket. Alternatively, you can request access to a Google Drive folder containing the latest trained models [here](https://drive.google.com/drive/folders/1_oLBxveioKtw7LyMJfism745USe9tEGZ?usp=sharing).

- Feature name sets are specified in `config.yaml` under `features`.
  These are referenced in `config.yaml` under `training.classes.<class>.features`.

- Feature stats to be used for feature scaling/standardization before training
  is defined in `config.yaml` under `feature_stats`.

- We use [Weights & Biases](https://wandb.com) to track experiments.
  Project details and access credentials can be defined in `config.yaml` under `wandb`.

An example `bash` script to train all classifier families:

```sh
for class in pnp longt i fla ew eb ea e agn bis blyr ceph dscu lpv mir puls rrlyr rscvn srv wuma yso; \
  do echo $class; \
  for state in 1 2 3 4 5 6 7 8 9 42; \
    do ./scope.py train \
      --tag=$class --path_dataset=data/training/dataset.d15.csv \
      --scale_features=min_max --batch_size=64 \
      --epochs=300 --patience=30 --random_state=$state \
      --verbose=1 --gpu=1 --conv_branch=true --save; \
  done; \
done;
```

If `--save` is specified during training, an HDF5 file of the model's layers and weights will be saved. This file can be directly used for additional training and inferencing.

A training script containing one line per class to be trained can be generated by running `./scope.py create_training_script`, for example:
```bash
./scope.py create_training_script --filename='train_dnn.sh' --min_count=100 --pre_trained_group_name='experiment' --add_keywords='--save --batch_size=32 --group=new_experiment'
```
A path to the training set may be provided as input to this method or otherwise taken from `config.yaml` (`training: dataset:`). To continue training on existing models, specify the `--pre_trained_group_name` keyword containing the models in `create_training_script`. The string specified in  `--add_keywords` serves as a catch-all for additional keywords that the user wishes to be included in each line of the script.

If `--pre_trained_group_name` is specified and the `--train_all` keyword is set, the output script will train all classes specified in `config.yaml` regardless of whether they have a pre-trained model. If `--train_all` is not set (the default), the script will limit training to classes that have an existing trained model.

## Running inference

* Inference requires the following steps: download ids of a field, download features for all downloaded ids, run inference for all available pre-trained models.
* Requires `models/` folder in the root directory containing the pre-trained models for `dnn` and `xgboost`.
* The commands for inference of the field `<field_number>` (in order)
  ```
  ./tools/get_quad_ids.py --field=<field_number> --whole-field
  ./tools/get_features.py --field=<field_number> --whole-field
  ./get_all_preds.sh <field_number>
  ```
* Creates a single `.csv` file containing all ids of the field in the rows and inference scores for different classes across the columns.

## Handling different file formats
When our manipulations of `pandas` dataframes is complete, we want to save them in an appropriate file format with the desired metadata. Our code works with multiple formats, each of which have advantages and drawbacks:

- <b>Comma Separated Values (CSV, .csv):</b> in this format, data are plain text and columns are separated by commas. While this format offers a high level of human readability, it also takes more space to store and a longer time to write and read than other formats.

  `pandas` offers the `read_csv()` function and `to_csv()` method to perform I/O operations with this format. Metadata must be included as plain text in the file.

- <b>Hierarchical Data Format (HDF5, .h5):</b> this format stores data in binary form, so it is not human-readable. It takes up less space on disk than CSV files, and it writes/reads faster for numerical data. HDF5 does not serialize data columns containing structures like a `numpy` array, so file size improvements over CSV can be diminished if these structures exist in the data.

  `pandas` includes `read_hdf()` and `to_hdf()` to handle this format, and they require a package like [`PyTables`](https://www.pytables.org/) to work. `pandas` does not currently support the reading and writing of metadata using the above function and method. See `scope/utils.py` for code that handles metadata in HDF5 files.

- <b>Apache Parquet (.parquet):</b> this format stores data in binary form like HDF5, so it is not human-readable. Like HDF5, Parquet also offers significant disk space savings over CSV. Unlike HDF5, Parquet supports structures like `numpy` arrays in data columns.

  While `pandas` offers `read_parquet()` and `to_parquet()` to support this format (requiring e.g. [`PyArrow`](https://arrow.apache.org/docs/python/) to work), these again do not support the reading and writing of metadata associated with the dataframe.  See `scope/utils.py` for code that reads and writes metadata in Parquet files.

## Mapping between column names and Fritz taxonomies
The column names of training set files and Fritz taxonomy classifications are not the same by default. Training sets may also contain columns that are not meant to be uploaded to Fritz. To address both of these issues, we use a 'taxonomy mapper' file to connect local data and Fritz taxonomies.

This file must currently be generated manually, entry by entry. Each entry's key corresponds to a column name in the local file. The set of all keys is used to establish the columns of interest for upload or download. For example, if the training set includes columns that are not classifications, like RA and Dec, these columns should not be included among the entries in the mapper file. The code will then ignore these columns for the purpose of classification.

The fields associated with each key are `fritz_label` (containing the associated Fritz classification name) and `taxonomy_id` identifying the classification's taxonomy system. The mapper must have the following format, also demonstrated in `golden_dataset_mapper.json` and `DNN_AL_mapper.json`:

```
{
"variable":
    {"fritz_label": "variable",
      "taxonomy_id": 1012
    },

"periodic":
    {"fritz_label": "periodic",
      "taxonomy_id": 1012
    },

    .
    . [add more entries here]
    .

"CV":
    {"fritz_label": "Cataclysmic",
      "taxonomy_id": 1011
    }
}

```


## Scope Download Classification
inputs:
1. CSV file containing obj_id and/or ra dec coordinates. Set to "parse" to download sources by group id.
2. target group id(s) on Fritz for download (if CSV file not provided)
3. Index or page number (if in "parse" mode) to begin downloading (optional)
4. Flag to merge features from Kowalski with downloaded sources
5. Name of features catalog to query
6. Limit on number of sources to query at once
7. Filename of taxonomy mapper (JSON format)
8. Name of directory to save downloaded files
9. Name of file containing merged classifications and features
10. Output format of saved files, if not specified in (9). Must be one of parquet, h5, or csv.
11. Flag to add ZTF filter IDs (separate catalog query) to default features

process:
1. if CSV file provided, query by object ids or ra, dec
2. if CSV file not provided, bulk query based on group id(s)
3. get the classification/probabilities/periods of the objects in the dataset from Fritz
4. append these values as new columns on the dataset, save to new file
5. if merge_features, query Kowalski and merge sources with features, saving new CSV file
6. Fritz sources with multiple ztf_id annotations will generate multiple rows in the merged feature file
7. To skip the source download part of the code, provide an input CSV file containing columns named 'obj_id', 'classification', 'probability', 'period_origin', 'period', 'ztf_id_origin', and 'ztf_id'.

output: data with new columns appended.

```sh
./scope_download_classification.py -file sample.csv -group_ids 360 361 -start 10 -merge_features True -features_catalog ZTF_source_features_DR5 -features_limit 5000 -taxonomy_map golden_dataset_mapper.json -output_dir fritzDownload -output_filename merged_classifications_features -output_format parquet -get_ztf_filters
```

## Scope Upload Classification
inputs:
0. gloria object (include Kowalski host, port, protocol, and token or username+password in config.yaml)
1. CSV, HDF5 or Parquet file containing ra, dec, period, and labels
2. target group id(s) on Fritz for upload
3. Name(s) of input file columns containing classification probabilities (one column per label). Set this to "read" to automatically upload all classes specified in the taxonomy mapper at once.
4. Filename of taxonomy mapper (JSON format)
5. Comment to post (if specified)
6. Index to start uploading (zero-based)
7. Index to stop uploading (inclusive)
8. Skip photometry upload (existing sources only)
9.  Origin of ZTF data. If set, values in ztf_id CSV column will post as annotations.
10. Probability threshold for posted classification (values must be >= than this number to post)
11. Set -match_ids to match input and existing ZTF IDs during upload. It is recommended to instead match obj_ids (see next line)
12. Set -use_existing_obj_id to provide existing source names in a column named 'obj_id' (a coordinate-based ID is otherwise generated by default)
13. Set -post_upvote to post an upvote to newly uploaded classifications. Not recommended when posting automated classifications for active learning.
14. Set -check_labelled_box to check the 'labelled' box for each source when uploading classifications. Not recommended when posting automated classifications for active learning.
15. Set -write_obj_id to output a copy of the input file with an 'obj_id' column containing the coordinate-based IDs for each posted object. Use this file as input for future uploads to add to this column.
16. Set -result_dir to customize the directory where the upload results file is saved. Default is 'fritzUpload' within the tools directory.
17. Set -result_filetag to customize the tag appended to the result filename. Default is 'fritzUpload'.
18. Set -result_format to one of csv, h5 or parquet to customize the result file format. Default is parquet.
19. Set -replpace_classifications to delete each source's existing classifications before posting new ones.

process:
1. check if each input source exists by comparing input and existing ZTF IDs
2. save the objects to Fritz group if new
3. in batches, upload the classifications of the objects in the dataset to target group on Fritz
4. duplicate classifications will not be uploaded to Fritz. If n classifications are manually specified, probabilities will be sourced from the last n columns of the dataset.
5. post ZTF ID annotations, subscritping for multiple close sources (e.g. ztf_id_2, ztf_id_3)
5. (post comment to each uploaded source)

```sh
./scope_upload_classification.py -file sample.csv -group_ids 500 250 750 -classification variable flaring -taxonomy_map map.json -comment confident -start 35 -stop 50 -skip_phot -p_threshold 0.9 -write_obj_id -result_format csv
```

## Scope Manage Annotation
inputs:
1. action (one of "post", "update", or "delete")
2. source (ZTF ID or path to .csv file with multiple objects (ID column "obj_id"))
3. target group id(s) on Fritz
4. origin name of annotation
5. key name of annotation
6. value of annotation (required for "post" and "update" - if source is a .csv file, value will auto-populate from source[key])

process:
1. for each source, find existing annotations (for "update" and "delete" actions)
2. interact with API to make desired changes to annotations
3. confirm changes with printed messages

```sh
./scope_manage_annotation.py -action post -source sample.csv -group_ids 200 300 400 -origin revisedperiod -key period
```

## Scope Upload Disagreements
inputs:
1. dataset
2. group id on Fritz
3. gloria object

process:
1. read in the csv dataset to pandas dataframe
2. get high scoring objects on DNN or on XGBoost from Fritz
3. get objects that have high confidence on DNN but low confidence on XGBoost and vice versa
4. get different statistics of those disagreeing objects and combine to a dataframe
5. filter those disagreeing objects that are contained in the training set and remove them
6. upload the remaining disagreeing objects to target group on Fritz

```sh
./scope_upload_disagreements.py -file dataset.d15.csv -id 360 -token sample_token
```
